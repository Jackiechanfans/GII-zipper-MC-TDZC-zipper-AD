#include "GIIBCHCodec.h"
#include <iostream>
#include "RandNum.h"


using namespace std;

extern CLCRandNum rndGen2;

GIIBCHCodec::GIIBCHCodec()
{
}

GIIBCHCodec::~GIIBCHCodec()
{
}

void GIIBCHCodec::Malloc()
{
	m_BasicDecoderType = BMBCH;
	m_GF.Malloc(m_len_symbol);	//Initialize GF(2^q), where q <- m_len_symbol;
	m_root0 = 1;				////Primitive element alpha
	check_len = new int[(num_of_intl + 1)];	
	m_codedim = new int[(num_of_intl + 1)];	

	dist = new int[(num_of_intl + 1)];  
	gen = new int* [num_of_intl + 1];	


	for (int i = 0; i <= num_of_intl; i++)
		dist[i] = t[i] * 2 + 1;


	for (int i = 0; i <= num_of_intl; i++)
	{
		if (dist[i] != 0)
			calGenerator(m_codelen + m_len_shorten, m_root0, *(dist + i), gen[i], *(check_len + i), eBCH_option);	//Obtain the generator vector
		m_codedim[i] = m_codelen - check_len[i];	
	}

}

void GIIBCHCodec::Free_GII()
{
	m_GF.Free();
	delete[] t;
	delete[] check_len;
	delete[] m_codedim;
	delete[] dist;
	for (int i = 0; i <= num_of_intl; i++)
		delete[]gen[i];
}

void GIIBCHCodec::Encoder(int* uu, int* cc, int m_codechk, int m_codedim,int* m_generator)
{
	int i, j;
	int quotient;
	int* m_rx;
	m_rx = new int[m_codechk];

	//information vector uu = (uu[0] uu[1] uu[2] ... uu[k-1])
	//information polynomial uu(x) = uu[0] + uu[1]*x + uu[2]*x^2 +...+ uu[k-1]*x^(k-1) 
	//codeword vector cc = (cc[0] cc[1] cc[2] ... cc[n-1])
	//codeword polynomial cc[x] = cc[0] + cc[1]*x +...+ cc[n-k-1]*x^(n-k-1) + uu(x)*x^(n-k)
	//systematic bits are located at right part
	//the left part is the parity check bits, which are generated by uu(x)*x^(n-k) mod g(x) 

	for (i = 0; i < m_codechk; i++)
		cc[i] = 0;

	for (i = m_codechk; i < m_codelen; i++)
		cc[i] = uu[i - m_codechk];





	//programed by Huang Xiujie
	//modified by Xiao Ma for binary BCH
	//long division
	for (j = 0; j < m_codechk; j++)
		m_rx[j] = cc[m_codedim + j];//register of length m_codechk is initially filled by the right-most part of cc
									//by hand computation, the reister length should be m_codechk+1 [0,1,...,n-k]  

	for (i = 1; i <= m_codedim; i++)
	{
		quotient = m_rx[m_codechk - 1];//the current quotient because of the fact g[n-k] = 1;
									   //shift; at this clock, you may think [0,1,...,j,...,n-k-1]-->[-1,   0,   ..., j-1,  n-k-2] [quotient]
									   //[g[0], g[1] ..., g[j], g[n-k-1], g[n-k]] 
		for (j = m_codechk - 1; j > 0; j--)
			m_rx[j] = m_rx[j - 1] ^ (quotient & m_generator[j]); //multiplication, substraction 

		m_rx[0] = cc[m_codedim - i] ^ (quotient & m_generator[0]);//cc[k-i] is shifted into
	}
	//after cc[0] is shifted into the register, the division is ended; the remainder is in the register
	//after the n-k right most part of c is shifted into the register, we shift k times more.

	for (i = 0; i < m_codechk; i++)
		cc[i] = m_rx[i];

	delete[] m_rx;

	return;


}

//Computer syndorme
int GIIBCHCodec::zipper_syd(int m_dist_0, int m_dist, int m_codelen,int* rr, int* msyndrome)
{
	int temp;
	for (int i = m_dist_0; i < m_dist; i++) {
		msyndrome[i] = 0;
		for (int j = 0; j < m_codelen; j++) {
			if (rr[j]) {
				temp = m_GF.Pow(m_GF.Exp[m_root0 + i - 1], j);
				temp = m_GF.Mult(temp, rr[j]);
				msyndrome[i] = m_GF.Add(msyndrome[i], temp);
			}
		}

	}

	for (int i = m_dist_0; i < m_dist; i++)
	{
		if (msyndrome[i] != 0)
		{		
			return 1;
		}
	}
	return 3;
}

void GIIBCHCodec::LFSR_process(int m_dist_0, int m_dist, int* m_syndrome, int* m_Lambda, int deg_Lambda)
{
	int temp;
	for (int i = m_dist_0; i < m_dist; i++)
	{
		temp = 0;
		for (int j = 1; j <= deg_Lambda; j++)
		{
			temp = m_GF.Add(temp, m_GF.Mult(m_Lambda[j], m_syndrome[i - j]));
		}
		m_syndrome[i] = temp;
	}
}

void GIIBCHCodec::Updated_nestedsyn(int m_dist_0, int m_dist, int* m_syndrome, int* nested_syn, int l_val, int dim)
{
	for (int z = m_dist_0; z < m_dist; z++)		//update nested syndromes
	{
		nested_syn[z] = m_GF.Add(nested_syn[z], m_GF.Mult(m_GF.Pow(m_GF.Exp[m_root0 + z - 1], dim * l_val), m_syndrome[z]));
		/*nested_syn[z] ^= m_GF.Mult(m_GF.Pow(m_GF.Exp[m_root0 + z - 1], dim * l_val), m_syndrome[z]);*/
	}
}



//BM decoding algorithm
unsigned char GIIBCHCodec::Decoder(int* rr, int* err, int& r, int& L, int* m_B, int* m_Lambda, int& m_codelen, int* m_syndrome,int m_dist, int& L_1, int& deg_Lambda)
{
	int i, j;
	int temp;
	int delta;
	unsigned char decoding_success = 2;
	int* m_T;
	m_T = new int[m_dist];




	while (r < m_dist - 1)
	{
		r = r + 1;
		delta = 0;



		for (j = 0; j <= L; j++)							//delta == d_k  L =l_k  r: procedure(k) m_Lambda : error-locator polynomial
			delta = m_GF.Add(delta, m_GF.Mult(m_Lambda[j], m_syndrome[r - j]));

		m_T[0] = m_Lambda[0];
		for (j = 1; j < r; j++)
			m_T[j] = m_GF.Add(m_Lambda[j], m_GF.Mult(delta, m_B[j - 1]));

		if (delta != 0 && 2 * L <= r - 1)
		{
			for (j = 0; j < r; j++) {
				m_B[j] = m_GF.Div(m_Lambda[j], delta);
			}
			L = r - L;
		}
		else
		{
			for (j = m_dist - 1; j > 0; j--)
				m_B[j] = m_B[j - 1];
			m_B[0] = 0;
		}

		for (j = 0; j < r; j++)
		{
			m_Lambda[j] = m_T[j];
		}



	}

	deg_Lambda = 0;
	for (i = 0; i < m_dist; i++) {
		if (m_Lambda[i] != 0)
			deg_Lambda = i;
	}



	if (deg_Lambda != L || deg_Lambda > (m_dist - 1) / 2) {//the degree of the connection polynomial is not equal to the length of the registers 
		L_1 = 0;
		decoding_success = 2;
	}
	else {//Find the roots of error-location polynomial
		L_1 = 0;
		temp = 0;
		for (j = 0; j <= deg_Lambda; j++)
			temp = m_GF.Add(temp, m_Lambda[j]);
		if (temp == 0) {
			L_1++;
			err[0] = 1;
		}

		for (i = 1; i < m_codelen; i++) {
			temp = 0;
			for (j = 0; j <= deg_Lambda; j++)
				temp = m_GF.Add(temp, m_GF.Mult(m_Lambda[j], m_GF.Pow(m_GF.Exp[m_GF.m_num_element - 1 - i], j)));

			if (temp == 0) {
				L_1++;
				err[i] = 1;
			}
		}


		if (L_1 == deg_Lambda) {//L is the number of different roots
			decoding_success = 1;
		}
		else {//lambda(x) with repeated roots is not a valid error-location polynomial 
			decoding_success = 2;
			L_1 = -1;
			for (i = 0; i < m_codelen; i++)
				err[i] = 0;
		}
	}

	delete[] m_T;
	return decoding_success;

}

void GIIBCHCodec::Computer_syd(int m_dist_0, int m_dist, int* syd0, int* syd1, int* I)
{
	int l[2];
	int a = 0;
	int temp = 0;
	int temp_syd;
	int q;
	for (int i = 0; i <= 2; i++)
	{
		if (I[i] == 2)
		{ 
			l[a] = i;
			a++;
		}
		
	}

	

	for (int i = m_dist_0; i < m_dist; i++)
	{	
		temp = m_GF.Pow(m_GF.Exp[m_root0 + i - 1], l[1]);
		q = m_GF.Add(temp, m_GF.Pow(m_GF.Exp[m_root0 + i - 1], l[0]));
		temp = m_GF.Mult(temp, syd0[i]);	
		temp = m_GF.Add(temp, syd1[i]);
		temp_syd = m_GF.Div(temp,q);

		temp = m_GF.Pow(m_GF.Exp[m_root0 + i - 1], l[0]);
		temp = m_GF.Mult(temp, syd0[i]);
		temp = m_GF.Add(temp, syd1[i]);
		syd1[i] = m_GF.Div(temp, q);

		syd0[i] = temp_syd;

	}

}


void GIIBCHCodec::Computer_syn3(int m_dist_0, int m_dist, int* syd0, int* syd1, int* syd2, int** syn, vector<int> &I)
{
	int det = 0;
	int A[3][3];
	int temp[3];
	int temper;
	for (int i = m_dist_0; i < m_dist; i++)
	{
		det = m_GF.Mult(power(i,I[1]), power(i, 2*I[2]));
		det = m_GF.Add(det, m_GF.Mult(power(i, I[2]), power(i, 2 * I[0])));
		det = m_GF.Add(det, m_GF.Mult(power(i, I[0]), power(i, 2 * I[1])));
		det = m_GF.Add(det, m_GF.Mult(power(i, I[1]), power(i, 2 * I[0])));
		det = m_GF.Add(det, m_GF.Mult(power(i, I[2]), power(i, 2 * I[1])));
		det = m_GF.Add(det, m_GF.Mult(power(i, I[0]), power(i, 2 * I[2])));
		A[0][0] = m_GF.Add(m_GF.Mult(power(i, I[1]), power(i, 2 * I[2])), m_GF.Mult(power(i, I[2]), power(i, 2 * I[1])));
		A[0][1] = m_GF.Add(m_GF.Mult(power(i, I[0]), power(i, 2 * I[2])), m_GF.Mult(power(i, I[2]), power(i, 2 * I[0])));
		A[0][2] = m_GF.Add(m_GF.Mult(power(i, I[0]), power(i, 2 * I[1])), m_GF.Mult(power(i, I[1]), power(i, 2 * I[0])));
		A[1][0] = m_GF.Add(power(i, 2 * I[2]), power(i, 2 * I[1]));
		A[1][1] = m_GF.Add(power(i, 2 * I[2]), power(i, 2 * I[0]));
		A[1][2] = m_GF.Add(power(i, 2 * I[1]), power(i, 2 * I[0]));
		A[2][0] = m_GF.Add(power(i, I[2]), power(i, I[1]));
		A[2][1] = m_GF.Add(power(i, I[2]), power(i, I[0]));
		A[2][2] = m_GF.Add(power(i, I[1]), power(i, I[0]));

		temp[0] = syd0[i];
		temp[1] = syd1[i];
		temp[2] = syd2[i];

		temper = m_GF.Add(m_GF.Mult(A[0][0], temp[0]), m_GF.Mult(A[1][0], temp[1]));
		temper = m_GF.Add(temper, m_GF.Mult(A[2][0], temp[2]));
		syn[I[0]][i] = m_GF.Div(temper,det);

		temper = m_GF.Add(m_GF.Mult(A[0][1], temp[0]), m_GF.Mult(A[1][1], temp[1]));
		temper = m_GF.Add(temper, m_GF.Mult(A[2][1], temp[2]));
		syn[I[1]][i] = m_GF.Div(temper, det);

		temper = m_GF.Add(m_GF.Mult(A[0][2], temp[0]), m_GF.Mult(A[1][2], temp[1]));
		temper = m_GF.Add(temper, m_GF.Mult(A[2][2], temp[2]));
		syn[I[2]][i] = m_GF.Div(temper, det);

	}
	


}

void GIIBCHCodec::Computer_syn2(int m_dist_0, int m_dist, int* syd0, int* syd1, int** syn, vector<int> &I)
{
	int det = 0;
	int temp[2];
	for (int i = m_dist_0; i < m_dist; i++)
	{
		det = 0;
		det = m_GF.Add(power(i, I[0]), power(i, I[1]));

		temp[0] = syd0[i];
		temp[1] = syd1[i];

		syn[I[0]][i] = m_GF.Div(m_GF.Add(m_GF.Mult(power(i, I[1]), temp[0]), temp[1]), det);
		syn[I[1]][i] = m_GF.Div(m_GF.Add(m_GF.Mult(power(i, I[0]), temp[0]), temp[1]), det);

	}
	//int temp = 0;
	//int temp_syd, q;

	//for (int i = m_dist_0; i < m_dist; i++)
	//{
	//	temp = m_GF.Pow(m_GF.Exp[m_root0 + i - 1], I[1]);
	//	q = m_GF.Add(temp, m_GF.Pow(m_GF.Exp[m_root0 + i - 1], I[0]));
	//	temp = m_GF.Mult(temp, syd0[i]);
	//	temp = m_GF.Add(temp, syd1[i]);
	//	temp_syd = m_GF.Div(temp, q);

	//	temp = m_GF.Pow(m_GF.Exp[m_root0 + i - 1], I[0]);
	//	temp = m_GF.Mult(temp, syd0[i]);
	//	temp = m_GF.Add(temp, syd1[i]);
	//	syn[I[1]][i] = m_GF.Div(temp, q);

	//	syn[I[0]][i] = temp_syd;

	//}


}

int GIIBCHCodec::power(int i, int index)
{
	return m_GF.Pow(m_GF.Exp[m_root0 + i - 1], index);
}




BSC_channel::BSC_channel()
{
}

BSC_channel::~BSC_channel()
{
}

void BSC_channel::BSC_Channel(int* cc, int* rr,int start_len, int len, double pro)
{

	for (int t = start_len; t < len; t++)
		rr[t] = (rndGen2.Uniform() < pro ? 1 : 0);
	//	    uu[t] = 0;

	for (int i = start_len; i < len; i++)
		rr[i] = rr[i] ^ cc[i];

	return;
}
