#include "Stdafx.h"
#include "Utility.h"
#include "BCHCodec.h"
#include "RandNum.h"

extern CLCRandNum rndGen3;

CBCHCodec::CBCHCodec()
{
}

CBCHCodec::~CBCHCodec()
{
}

/////////////////////////////////////////////////
void CBCHCodec::Malloc(int code_no, char *file_name){
	
	char temp_str[80] = { ' ' };
	char mark[80];
	FILE *fp;

	if ((fp = fopen(file_name, "r")) == NULL) {
		fprintf(stderr, "\nCannot open %s", file_name);
		exit(3);
	}
	sprintf(mark, "BCH***%d***PARAMETERS", code_no);
	while (strcmp(temp_str, mark) != 0)
		fscanf(fp, "%s", temp_str);
//
	fscanf(fp, "%s", temp_str);
	fscanf(fp, "%d", &m_len_symbol);
//缩短前码长
	fscanf(fp, "%s", temp_str);
	fscanf(fp, "%d", &m_codelen);
//
	fscanf(fp, "%s", temp_str);
	fscanf(fp, "%d", &m_len_shorten);
//
	fscanf(fp, "%s", temp_str);
	fscanf(fp, "%d", &m_root0);
//
	fscanf(fp, "%s", temp_str);
	fscanf(fp, "%d", &m_dist);

	fscanf(fp, "%s", temp_str);
	fscanf(fp, "%s", m_BasicDecoderStr);

	//fscanf(fp, "%s", temp_str);
	//fscanf(fp, "%s", m_BasicDecoderStr);	
	
	fclose(fp);

	m_tmin = (m_dist - 1) / 2;
	if (strcmp(m_BasicDecoderStr, "BM") == 0)
		m_BasicDecoderType = BMBCH;
	else if (strcmp(m_BasicDecoderStr, "GS") == 0)
		m_BasicDecoderType = GSBCH;
	else if (strcmp(m_BasicDecoderStr, "TL") == 0)
		m_BasicDecoderType = TLBCH;

	m_GF.Malloc(m_len_symbol);
	calGenerator(m_codelen, m_root0, m_dist, m_generator, m_codechk,0);

	m_codelen -= m_len_shorten;
	m_codedim = m_codelen - m_codechk;
	m_coderate = (double)m_codedim / m_codelen;

	m_syndrome = new int[m_dist];//其实只要syndrome[1],syndrome[3],syndrome[5]...共tmin个就足以描述，因为syndrome[2*i]=syndrome[i]^2
	m_err = new int[m_codelen];
	m_cc_hat = new int[m_codelen];

	//Encoder
	m_rx = new int[m_codechk];
	
	//BMDecoder
	m_Lambda = new int[m_dist];
	m_B = new int[m_dist];
	m_T = new int[m_dist];
	
	//for error-and-erasure decoding
	m_rr_1 = new int[m_codelen];
	m_rr_2 = new int[m_codelen];
	m_uu_hat_1 = new int[m_codedim];
	m_uu_hat_2 = new int[m_codedim];
	m_cc_hat_1 = new int[m_codelen];
	m_cc_hat_2 = new int[m_codelen];


	if ((fp = fopen("snrber.txt", "a+")) == NULL) {
		printf("\n Cannot open the file!!!\n");
		exit(1);
	}
	fprintf(fp, "%%%%BCH parameter = [q, n , k, t] = [%d , %d , %d , %d]\n",
		m_len_symbol, m_codelen, m_codedim, m_tmin);
	fprintf(fp, "\n%%parameter: SNR    BER\n");
	fclose(fp);

	if ((fp = fopen("snrfer.txt", "a+")) == NULL) {
		printf("\n Cannot open the file!!!\n");
		exit(1);
	}
	fprintf(fp, "%%%%BCH parameter = [q, n , k, t] = [%d , %d , %d , %d]\n",
		m_len_symbol, m_codelen, m_codedim, m_tmin);
	fclose(fp);

	return;
}
/////////////////////////////////////////////////
void CBCHCodec::Free(){
	
	m_GF.Free();

	delete[]m_generator;
	delete[]m_syndrome;
	delete[]m_cc_hat;
	
	delete[]m_rr_1;
	delete[]m_rr_2;
	delete[]m_uu_hat_1;
	delete[]m_uu_hat_2;
	delete[]m_cc_hat_1;
	delete[]m_cc_hat_2;

	delete[]m_Lambda;
	delete[]m_B;
	delete[]m_T;
	delete[]m_err;
	delete[]m_rx;


	return;
}
/////////////////////////////////////////////////
void CBCHCodec::Encoder(int* uu, int* cc){
	int i, j;
	int quotient;

	//information vector uu = (uu[0] uu[1] uu[2] ... uu[k-1])
	//information polynomial uu(x) = uu[0] + uu[1]*x + uu[2]*x^2 +...+ uu[k-1]*x^(k-1) 
	//codeword vector cc = (cc[0] cc[1] cc[2] ... cc[n-1])
	//codeword polynomial cc[x] = cc[0] + cc[1]*x +...+ cc[n-k-1]*x^(n-k-1) + uu(x)*x^(n-k)
	//systematic bits are located at right part
	//the left part is the parity check bits, which are generated by uu(x)*x^(n-k) mod g(x) 
	for (i = 0; i < m_codechk; i++)
		cc[i] = 0;

	for (i = m_codechk; i < m_codelen; i++)
		cc[i] = uu[i - m_codechk];

	//programed by Huang Xiujie
	//modified by Xiao Ma for binary BCH
	//long division
	for (j = 0; j < m_codechk; j++)
		m_rx[j] = cc[m_codedim + j];//register of length m_codechk is initially filled by the right-most part of cc
									//by hand computation, the reister length should be m_codechk+1 [0,1,...,n-k]  

	for (i = 1; i <= m_codedim; i++)
	{
		quotient = m_rx[m_codechk - 1];//the current quotient because of the fact g[n-k] = 1;
									   //shift; at this clock, you may think [0,1,...,j,...,n-k-1]-->[-1,   0,   ..., j-1,  n-k-2] [quotient]
									   //[g[0], g[1] ..., g[j], g[n-k-1], g[n-k]] 
		for (j = m_codechk - 1; j > 0; j--)
			m_rx[j] = m_rx[j - 1] ^ (quotient & m_generator[j]); //multiplication, substraction 

		m_rx[0] = cc[m_codedim - i] ^ (quotient & m_generator[0]);//cc[k-i] is shifted into
	}
	//after cc[0] is shifted into the register, the division is ended; the remainder is in the register
	//after the n-k right most part of c is shifted into the register, we shift k times more.

	for (i = 0; i < m_codechk; i++)
		cc[i] = m_rx[i];

	return;
}
/////////////////////////////////////////////////
bool CBCHCodec::Computing_Syndrome(int* rr, int* syndrome){
	int i,j;
	bool detection_error = false;
	int temp;
	for (i = 1; i < m_dist; i++) {		//m_dist :最小码距
		m_syndrome[i] = 0;
		for (j = 0; j < m_codelen; j++) {
			if (rr[j]) {
				temp = m_GF.Pow(m_GF.Exp[m_root0 + i - 1], j);
				temp = m_GF.Mult(temp, rr[j]);
				m_syndrome[i] = m_GF.Add(m_syndrome[i], temp);
			}
		}
		if (m_syndrome[i] != 0)
			detection_error = true;
	}
	return detection_error;
}
/////////////////////////////////////////////////
bool CBCHCodec::Decoder_HIHO(int *rr, int *uu_hat, int *cc_hat, int *err){
	bool isSuc = false;
	switch (m_BasicDecoderType)
	{
	case BMBCH:
		isSuc = BMDecoder(rr, uu_hat, cc_hat, err);
		break;
	case TLBCH:
		isSuc = TLDecoder(rr, uu_hat, cc_hat, err);
		break;
	default:
		break;
	}
	return isSuc;
}
/////////////////////////////////////////////////
bool CBCHCodec::Decoder_HIHO(int *rr, int *uu_hat, int *cc_hat) {
	return Decoder_HIHO(rr, uu_hat, cc_hat, m_err);
}
/////////////////////////////////////////////////
bool CBCHCodec::Decoder_HIHO(int *rr, int *uu_hat) {
	return Decoder_HIHO(rr, uu_hat, m_cc_hat, m_err);
}
/////////////////////////////////////////////////
bool CBCHCodec::Decoder_HIHO_syndrome(int *syndrome, int *err) {
	bool isSuc = false;
	switch (m_BasicDecoderType)
	{
	case BMBCH:
		isSuc = BMDecoder_syndrome(syndrome, err);
		break;
	case TLBCH:
		isSuc = TLDecoder_syndrome(syndrome, err);
		break;
	default:
		break;
	}
	return isSuc;
}
/////////////////////////////////////////////////
bool CBCHCodec::Decoder_HIHO_EraErr(int *rr, int *uu_hat, int *cc_hat){


	bool flag1, flag2;
	int count1 = m_codelen, count2 = m_codelen;
	int countera;

	countera = 0;
	for (int i = 0; i < m_codelen; i++) {
		if (rr[i] == ERASE) {
			m_rr_1[i] = (rndGen3.Uniform() < 0.5 ? 0 : 1);
			m_rr_2[i] = 1 - m_rr_1[i];
			countera++;
		}
		else {
			m_rr_1[i] = rr[i];
			m_rr_2[i] = rr[i];
		}
	}
	if (countera > m_codechk) {
		for (int i = 0; i < m_codedim; ++i)
			uu_hat[i] = m_rr_2[i + m_codechk];
		for (int i = 0; i < m_codechk; ++i)
			cc_hat[i] = ERASE;
		return false;
	}
	flag1 = Decoder_HIHO(m_rr_1, m_uu_hat_1, m_cc_hat_1);
	flag2 = Decoder_HIHO(m_rr_2, m_uu_hat_2, m_cc_hat_2);
	if ( !(flag1 || flag2)) {
		for (int i = 0; i < m_codedim; ++i)
			uu_hat[i] = m_rr_2[i + m_codechk];
		for (int i = 0; i < m_codechk; ++i)
			cc_hat[i] = ERASE;
		return false;
	}
	else {
		if (flag1) {
			count1 = 0;
			for (int i = 0; i < m_codelen; i++)
				if (rr[i] != ERASE && rr[i] != m_cc_hat_1[i])
					count1++;
		}
		if (flag2) {
			count2 = 0;
			for (int i = 0; i < m_codelen; i++)
				if (rr[i] != ERASE && rr[i] != m_cc_hat_2[i])
					count2++;
		}
		if (count1 <= count2) {
			for (int i = 0; i < m_codedim; i++)
				uu_hat[i] = m_uu_hat_1[i];
			for (int i = 0; i < m_codelen; i++)
				cc_hat[i] = m_cc_hat_1[i];
		}
		else {
			for (int i = 0; i < m_codedim; i++)
				uu_hat[i] = m_uu_hat_2[i];
			for (int i = 0; i < m_codelen; i++)
				cc_hat[i] = m_cc_hat_2[i];
		}
		return true;
	}

}
/////////////////////////////////////////////////
bool CBCHCodec::BMDecoder(int *rr, int *uu_hat, int *cc_hat, int *err){		//rr 255 uu 231 cc-hat 255(output code) uu-hat 231(output imformation)
	int i, j;
	int temp;

	int r;
	int L;
	int delta;
	int deg_Lambda;

	int detection_error = 0;
	bool decoding_success = true;

	//computing syndrome
	detection_error = Computing_Syndrome(rr, m_syndrome);

	if (detection_error == 0) {
		for (i = 0; i < m_codelen; i++){
			cc_hat[i] = rr[i];
			err[i] = 0;
			if (i >= m_codechk)
				uu_hat[i - m_codechk] = rr[i];
		}
		return decoding_success;
	}

	//finding error-locator polynomial
	//initialization
	for (i = 0; i < m_dist; i++) {
		m_Lambda[i] = 0;
		m_B[i] = 0;
	}
	m_Lambda[0] = 1;
	m_B[0] = 1;
	r = 0;
	L = 0;

	while (r < m_dist - 1) {
		r = r + 1;

		delta = 0;

		for (j = 0; j <= L; j++)							//delta == d_k  L =l_k  r: procedure(k) m_Lambda : error-locator polynomial
			delta = m_GF.Add(delta, m_GF.Mult(m_Lambda[j], m_syndrome[r - j]));

		if (delta == 0) {
			for (j = m_dist - 1; j > 0; j--)
				m_B[j] = m_B[j - 1];
			m_B[0] = 0;
		}
		else {
			m_T[0] = m_Lambda[0];			//m_T : ^
			for (j = 1; j < m_dist; j++)
				m_T[j] = m_GF.Add(m_Lambda[j], m_GF.Mult(delta, m_B[j - 1]));

			if (2 * L > r - 1) {
				for (j = 0; j < m_dist; j++)
					m_Lambda[j] = m_T[j];
				for (j = m_dist - 1; j > 0; j--)
					m_B[j] = m_B[j - 1];
				m_B[0] = 0;
			}
			else {
				for (j = 0; j < m_dist; j++) {
					m_B[j] = m_GF.Div(m_Lambda[j], delta);
					m_Lambda[j] = m_T[j];
				}

				L = r - L;
			}
		}
	}

	//finding error locator
	deg_Lambda = 0;
	for (i = 0; i < m_dist; i++) {
		if (m_Lambda[i] != 0)
			deg_Lambda = i;
	}

	for (i = 0; i < m_codelen; i++)
		err[i] = 0;

	if (deg_Lambda != L) {//the degree of the connection polynomial is not equal to the length of the registers 

		decoding_success = false;
		for (i = m_codechk; i < m_codelen; i++)
			uu_hat[i - m_codechk] = rr[i];

	}
	else {//Find the roots of error-location polynomial
		L = 0;
		temp = 0;
		for (j = 0; j <= deg_Lambda; j++)
			temp = m_GF.Add(temp, m_Lambda[j]);
		if (temp == 0) {
			L++;
			err[0] = 1;
		}

		for (i = 1; i < m_codelen; i++) {
			temp = 0;
			for (j = 0; j <= deg_Lambda; j++)
				temp = m_GF.Add(temp, m_GF.Mult(m_Lambda[j], m_GF.Pow(m_GF.Exp[m_GF.m_num_element - 1 - i], j)));

			if (temp == 0) {
				L++;
				err[i] = 1;
			}
		}

		if (L == deg_Lambda) {//L is the number of different roots
			for (i = 0; i < m_codelen; i++)
				cc_hat[i] = err[i] ^ rr[i];
		}
		else {//lambda(x) with repeated roots is not a valid error-location polynomial 

			decoding_success = false;
			for (i = m_codechk; i < m_codelen; i++)
				uu_hat[i - m_codechk] = rr[i];
		}
	}

	if (decoding_success) {
		for (i = m_codechk; i < m_codelen; i++)
			uu_hat[i - m_codechk] = cc_hat[i];
	}
	else {
		for (i = 0; i < m_codelen; i++)
			cc_hat[i] = ERASE;
	}

	return decoding_success;
}
/////////////////////////////////////////////////
bool CBCHCodec::BMDecoder_syndrome(int *syndrome, int *err) {
	int i, j;
	int temp;

	int r;
	int L;
	int delta;
	int deg_Lambda;

	bool detection_error = false;
	for (i = 0; i < m_codechk; i++) {
		if (syndrome[i])
			detection_error = true;
	}
	bool decoding_success = true;

	if (!detection_error) {
		for (i = 0; i < m_codelen; i++) {
			err[i] = 0;
		}
		return decoding_success;
	}

	//finding error-locator polynomial
	//initialization
	for (i = 0; i < m_dist; i++) {
		m_Lambda[i] = 0;
		m_B[i] = 0;
	}
	m_Lambda[0] = 1;
	m_B[0] = 1;
	r = 0;
	L = 0;

	while (r < m_dist - 1) {
		r = r + 1;

		delta = 0;

		for (j = 0; j <= L; j++)
			delta = m_GF.Add(delta, m_GF.Mult(m_Lambda[j], m_syndrome[r - j]));

		if (delta == 0) {
			for (j = m_dist - 1; j > 0; j--)
				m_B[j] = m_B[j - 1];
			m_B[0] = 0;
		}
		else {
			m_T[0] = m_Lambda[0];
			for (j = 1; j < m_dist; j++)
				m_T[j] = m_GF.Add(m_Lambda[j], m_GF.Mult(delta, m_B[j - 1]));

			if (2 * L > r - 1) {
				for (j = 0; j < m_dist; j++)
					m_Lambda[j] = m_T[j];
				for (j = m_dist - 1; j > 0; j--)
					m_B[j] = m_B[j - 1];
				m_B[0] = 0;
			}
			else {
				for (j = 0; j < m_dist; j++) {
					m_B[j] = m_GF.Div(m_Lambda[j], delta);
					m_Lambda[j] = m_T[j];
				}

				L = r - L;
			}
		}
	}

	//finding error locator
	deg_Lambda = 0;
	for (i = 0; i < m_dist; i++) {
		if (m_Lambda[i] != 0)
			deg_Lambda = i;
	}

	for (i = 0; i < m_codelen; i++)
		err[i] = 0;

	if (deg_Lambda != L) //the degree of the connection polynomial is not equal to the length of the registers 
		decoding_success = false;
	else {//Find the roots of error-location polynomial
		L = 0;
		temp = 0;
		for (j = 0; j <= deg_Lambda; j++)
			temp = m_GF.Add(temp, m_Lambda[j]);
		if (temp == 0) {
			L++;
			err[0] = 1;
		}

		for (i = 1; i < m_codelen; i++) {
			temp = 0;
			for (j = 0; j <= deg_Lambda; j++)
				temp = m_GF.Add(temp, m_GF.Mult(m_Lambda[j], m_GF.Pow(m_GF.Exp[m_GF.m_num_element - 1 - i], j)));
			if (temp == 0) {
				L++;
				err[i] = 1;
			}
		}
		if (L != deg_Lambda) //lambda(x) with repeated roots is not a valid error-location polynomial 
			decoding_success = false;
	}
	return decoding_success;
}
/////////////////////////////////////////////////
bool CBCHCodec::TLDecoder(int *rr, int *uu_hat, int *cc_hat, int *err){
	bool isSuc;
	int i;
	Computing_Syndrome(rr, m_syndrome);
	isSuc = TLDecoder_syndrome(m_syndrome, err);
	if (isSuc) {
		for (i = 0; i < m_codelen; ++i)
			cc_hat[i] = err[i] ^ rr[i];
		for (i = 0; i < m_codedim; ++i)
			uu_hat[i] = cc_hat[i + m_codechk];
	}
	else {
		for (i = 0; i < m_codedim; ++i)
			uu_hat[i] = rr[i + m_codechk];
		for (i = 0; i < m_codelen; ++i)
			cc_hat[i] = ERASE;
	}
	return isSuc;
}
/////////////////////////////////////////////////
bool CBCHCodec::TLDecoder_syndrome(int *syndrome, int *err) {
	int i;
	int t;
	int y;
	int D3, D5, D7, D9, D11;
	int xnum;//错误位置多项式根的个数
	int logx[6];//错误位置
	bool isSuc;
	bool iszero;
	iszero = true;
	for (i = 0; i < m_codelen; ++i)
		err[i] = 0;

	for (i = 1; i < m_dist; ++i)
		if (syndrome[i])
			iszero = false;
	if (iszero)
		return true;


	//计算Peterson算法中矩阵的行列式，从2阶开始算起
	//	|	1										|
	//  |	S2		S1		1						|
	//  |	S4		S3		S2		..				|
	//  |	..		..		..		..		..		|
	//  |	S(2t-4)	S(2t-3) ..		..		S(t-3)	|
	//  |	S(2t-2)	S(2t-1)	..		..		S(t-1)	|

	m_Det[0] = syndrome[1];//Det2=S1
	if (m_tmin > 1) {
		D3 = m_GF.Add(m_GF.Pow(syndrome[1], 3), syndrome[3]);//D3=S1^3+S3
		m_Det[1] = D3;//Det3=D3
	}
	if (m_tmin > 2) {
		D5 = m_GF.Add(m_GF.Pow(syndrome[1], 5), syndrome[5]);//D5=S1^5+S5
		m_Det[2] = m_GF.Mult(D5, syndrome[1]);//Det4=S1*D5
		m_Det[2] = m_GF.Add(m_Det[2], m_GF.Mult(syndrome[3], D3));//+S3*D3
	}
	if (m_tmin > 3) {
		D7 = m_GF.Add(m_GF.Pow(syndrome[1], 7), syndrome[7]);//D7=S1^7+S7
		m_Det[3] = m_GF.Mult(D7, D3);//Det5=D7*D3
		m_Det[3] = m_GF.Add(m_Det[3], m_GF.Mult(m_GF.Mult(syndrome[1], D3), m_Det[2]));//+S1*D3*Det4
		m_Det[3] = m_GF.Add(m_Det[3], m_GF.Pow(D5, 2));//+D5^2
	}
	if (m_tmin > 4) {
		D9 = m_GF.Add(m_GF.Pow(syndrome[1], 9), syndrome[9]);//D9=S1^9+S9
		m_Det[4] = m_GF.Add(D9, m_GF.Mult(m_GF.Pow(syndrome[1], 2), D7));//Det6=(D9+S1^2*D7
		m_Det[4] = m_GF.Add(m_Det[4], m_GF.Pow(D3, 3));//+D3^3
		m_Det[4] = m_GF.Add(m_Det[4], m_GF.Mult(syndrome[3], m_Det[2]));//+S3*Det4)
		m_Det[4] = m_GF.Mult(m_Det[4], m_Det[2]);//*Det4
		m_Det[4] = m_GF.Add(m_Det[4], m_GF.Mult(syndrome[1], m_GF.Pow(D7, 2)));//+S1*D7^2
		m_Det[4] = m_GF.Add(m_Det[4], m_GF.Pow(D5, 3));//+D5^3
		m_Det[4] = m_GF.Add(m_Det[4], m_GF.Mult(m_GF.Pow(syndrome[3], 3), m_GF.Pow(D3, 2)));//+S3^3*D3^2
	}
	if (m_tmin > 5) {
		D11 = m_GF.Add(m_GF.Pow(syndrome[1], 11), syndrome[11]);//D11=S1^11+S11
		m_Det[5] = m_GF.Add(D11, m_GF.Mult(m_GF.Pow(syndrome[1], 2), D9));//Det6=(D11+S1^2*D9
		m_Det[5] = m_GF.Add(m_Det[5], m_GF.Mult(syndrome[1], m_GF.Pow(D5, 2)));//+S1*D5^2)
		m_Det[5] = m_GF.Mult(m_Det[5], m_Det[3]);//*Det5
		m_Det[5] = m_GF.Add(m_Det[5], m_GF.Mult(m_GF.Mult(syndrome[1], m_GF.Pow(D7, 2)), m_Det[2]));//+S1*D7^2*Det4
		m_Det[5] = m_GF.Add(m_Det[5], m_GF.Mult(m_GF.Pow(D3, 5), m_Det[2]));//+D3^5*Det4
		m_Det[5] = m_GF.Add(m_Det[5], m_GF.Mult(m_GF.Mult(syndrome[3], m_GF.Pow(D3, 2)), m_GF.Pow(m_Det[2], 2)));//+S3*D3^2*Det4^2
		m_Det[5] = m_GF.Add(m_Det[5], m_GF.Mult(D3, m_GF.Pow(D9, 2)));//+D3*D9^2
		m_Det[5] = m_GF.Add(m_Det[5], m_GF.Pow(D7, 3));//+D7^3
		m_Det[5] = m_GF.Add(m_Det[5], m_GF.Mult(m_GF.Mult(m_GF.Pow(syndrome[1], 4), m_GF.Pow(D5, 2)), D7));//+S1^4*D5^2*D7
		m_Det[5] = m_GF.Add(m_Det[5], m_GF.Mult(m_GF.Mult(m_GF.Pow(D3, 3), D5), D7));//+D3^3*D5*D7
		m_Det[5] = m_GF.Add(m_Det[5], m_GF.Mult(m_GF.Mult(m_GF.Pow(syndrome[1], 2), syndrome[7]), m_GF.Pow(D3, 4)));//+S1^2*S7*D3^4
		m_Det[5] = m_GF.Add(m_Det[5], m_GF.Mult(m_GF.Pow(syndrome[3], 2), m_GF.Pow(D5, 3)));//+S3^2*D5^3
		m_Det[5] = m_GF.Add(m_Det[5], m_GF.Mult(syndrome[3], m_GF.Pow(D3, 6)));//+S3*D3^6
	}

	isSuc = true;
	switch (m_tmin)
	{
	case 6: {
		if (m_Det[4] && m_Det[5]) {
			m_sigma[0] = syndrome[1];//sigma1=S1

			m_sigma[1] = m_GF.Mult(D11, m_Det[2]);//sigma2=(D11*Det4
			m_sigma[1] = m_GF.Add(m_sigma[1], m_GF.Mult(m_GF.Mult(syndrome[5], D3), D9));//+S5*D3*D9
			m_sigma[1] = m_GF.Add(m_sigma[1], m_GF.Mult(m_GF.Mult(syndrome[1], D7), D9));//+S1*D7*D9
			m_sigma[1] = m_GF.Add(m_sigma[1], m_GF.Mult(m_GF.Pow(m_GF.Mult(syndrome[1], D3), 2), D9));//+S1^2*D3^2*D9
			m_sigma[1] = m_GF.Add(m_sigma[1], m_GF.Mult(syndrome[3], m_GF.Pow(D7, 2)));//+S3*D7^2
			m_sigma[1] = m_GF.Add(m_sigma[1], m_GF.Mult(m_GF.Pow(D5, 2), D7));//+D5^2*D7
			m_sigma[1] = m_GF.Add(m_sigma[1], m_GF.Mult(m_GF.Mult(m_GF.Mult(m_GF.Pow(syndrome[1], 2), syndrome[3]), D5), D7));//+S1^2*S3*D5*D7
			m_sigma[1] = m_GF.Add(m_sigma[1], m_GF.Mult(m_GF.Mult(syndrome[1], m_GF.Pow(D3, 2)), m_Det[3]));//+S1*D3^2*Det5)
			m_sigma[1] = m_GF.Div(m_sigma[1], m_Det[4]);//*Det6^(-1)

			m_sigma[2] = m_GF.Add(D3, m_GF.Mult(syndrome[1], m_sigma[1]));//sigma3=D3+S1*sigma2

			m_sigma[5] = m_GF.Div(m_Det[5], m_Det[4]);//sigma6=Det7/Det6

			if (D3) {
				m_sigma[3] = m_GF.Add(D7, m_GF.Mult(m_GF.Pow(syndrome[1], 2), syndrome[5]));//sigma4=D7+S1^2*S5
				m_sigma[3] = m_GF.Add(m_sigma[3], m_GF.Mult(syndrome[1], m_GF.Pow(syndrome[3], 2)));//+S1*S3^2
				m_sigma[3] = m_GF.Add(m_sigma[3], m_GF.Mult(syndrome[5], m_sigma[1]));//+S5*sigma2
				m_sigma[3] = m_GF.Add(m_sigma[3], m_GF.Mult(m_GF.Mult(m_GF.Pow(syndrome[1], 2), syndrome[3]), m_sigma[1]));//+S1^2*S3*sigma2
				m_sigma[3] = m_GF.Add(m_sigma[3], m_GF.Mult(syndrome[1], m_sigma[5]));//+S1*sigma6
				m_sigma[3] = m_GF.Div(m_sigma[3], D3);//*D3^(-1)
			}
			else if (D5) {//D3=0
				m_sigma[3] = m_GF.Add(D9, m_GF.Mult(m_GF.Pow(syndrome[1], 2), D7));//sigma4=D9+S1^2*D7
				m_sigma[3] = m_GF.Add(m_sigma[3], m_GF.Mult(D7, m_sigma[1]));//+D7*sigma2
				m_sigma[3] = m_GF.Add(m_sigma[3], m_GF.Mult(m_GF.Mult(m_GF.Pow(syndrome[1], 2), D5), m_sigma[1]));//+S1^2*D5*sigma2
				m_sigma[3] = m_GF.Div(m_sigma[3], D5);//*D5^(-1)
			}
			else {//D3=D5=0
				m_sigma[3] = m_GF.Add(D11, m_GF.Mult(m_GF.Pow(syndrome[1], 4), D7));//sigma4=D11+S1^4*D7
				m_sigma[3] = m_GF.Add(m_sigma[3], m_GF.Mult(D9, m_sigma[1]));//+D9*sigma2
				m_sigma[3] = m_GF.Div(m_sigma[3], D7);//*D7^(-1)
			}

			m_sigma[4] = m_GF.Add(D5, m_GF.Mult(D3, m_sigma[1]));//sigma5=D5+D3*sigma2
			m_sigma[4] = m_GF.Add(m_sigma[4], m_GF.Mult(m_GF.Pow(syndrome[1], 2), D3));//+S1^2*D3
			m_sigma[4] = m_GF.Add(m_sigma[4], m_GF.Mult(syndrome[1], m_sigma[3]));//+S1*sigma4

			xnum = 0;
			for (t = 1; t < m_GF.m_num_element; ++t) {
				y = m_GF.Add(t, m_sigma[0]);
				y = m_GF.Add(m_GF.Mult(t, y), m_sigma[1]);
				y = m_GF.Add(m_GF.Mult(t, y), m_sigma[2]);
				y = m_GF.Add(m_GF.Mult(t, y), m_sigma[3]);
				y = m_GF.Add(m_GF.Mult(t, y), m_sigma[4]);
				y = m_GF.Add(m_GF.Mult(t, y), m_sigma[5]);
				if (y == 0) {
					logx[xnum] = m_GF.Log[t];
					if (logx[xnum] >= m_codelen)
						isSuc = false;
					++xnum;
				}
			}
			if (xnum < 6)
				isSuc = false;
			if (isSuc)
				for (t = 0; t < xnum; ++t) {
					err[logx[t]] = 1;
				}

			return isSuc;
		}
	}
	case 5: {
		if (m_Det[3] && m_Det[4]) {
			m_sigma[0] = syndrome[1];//sigma1=S1

			m_sigma[1] = m_GF.Mult(D9, D3);//sigma2=(D9*D3
			m_sigma[1] = m_GF.Add(m_sigma[1], m_GF.Mult(D7, D5));//+D5*D7
			m_sigma[1] = m_GF.Add(m_sigma[1], m_GF.Mult(m_GF.Mult(syndrome[1], D5), m_Det[2]));//+S1*D5*Det4
			m_sigma[1] = m_GF.Add(m_sigma[1], m_GF.Pow(D3, 4));//+D3^4)
			m_sigma[1] = m_GF.Div(m_sigma[1], m_Det[3]);//*Det5^(-1)

			m_sigma[2] = m_GF.Add(D3, m_GF.Mult(syndrome[1], m_sigma[1]));//sigma3=D3+S1*sigma2

			if (D3) {
				m_sigma[3] = m_GF.Add(D7, m_GF.Mult(m_GF.Pow(syndrome[1], 2), syndrome[5]));//sigma4=D7+S1^2*S5
				m_sigma[3] = m_GF.Add(m_sigma[3], m_GF.Mult(syndrome[1], m_GF.Pow(syndrome[3], 2)));//+S1*S3^2
				m_sigma[3] = m_GF.Add(m_sigma[3], m_GF.Mult(syndrome[5], m_sigma[1]));//+S5*sigma2
				m_sigma[3] = m_GF.Add(m_sigma[3], m_GF.Mult(m_GF.Mult(m_GF.Pow(syndrome[1], 2), syndrome[3]), m_sigma[1]));//+S1^2*S3*sigma2
				m_sigma[3] = m_GF.Div(m_sigma[3], D3);//*D3^(-1)
			}
			else {//D3=0
				m_sigma[3] = m_GF.Add(D9, m_GF.Mult(m_GF.Pow(syndrome[1], 2), D5));//sigma4=D9+S1^4*D5
				m_sigma[3] = m_GF.Add(m_sigma[3], m_GF.Mult(D7, m_sigma[1]));//+D7*sigma2
				m_sigma[3] = m_GF.Div(m_sigma[3], D5);//*D5^(-1)
			}

			m_sigma[4] = m_GF.Div(m_Det[4], m_Det[3]);//sigma5=Det6/Det5

			xnum = 0;
			for (t = 1; t < m_GF.m_num_element; ++t) {
				y = m_GF.Add(t, m_sigma[0]);
				y = m_GF.Add(m_GF.Mult(t, y), m_sigma[1]);
				y = m_GF.Add(m_GF.Mult(t, y), m_sigma[2]);
				y = m_GF.Add(m_GF.Mult(t, y), m_sigma[3]);
				y = m_GF.Add(m_GF.Mult(t, y), m_sigma[4]);
				if (y == 0) {
					logx[xnum] = m_GF.Log[t];
					if (logx[xnum] >= m_codelen)
						isSuc = false;
					++xnum;
				}
			}
			if (xnum < 5)
				isSuc = false;
			if (isSuc)
				for (t = 0; t < xnum; ++t) {
					err[logx[t]] = 1;
				}

			return isSuc;
		}
	}
	case 4: {
		if (m_Det[2] && m_Det[3]) {
			m_sigma[0] = syndrome[1];//sigma1=S1

			m_sigma[1] = m_GF.Mult(syndrome[3], D5);//sigma2=(S3*D5
			m_sigma[1] = m_GF.Add(m_sigma[1], m_GF.Mult(syndrome[1], D7));//+S1*D7)
			m_sigma[1] = m_GF.Div(m_sigma[1], m_Det[2]);//*Det4^(-1)

			m_sigma[2] = m_GF.Add(D3, m_GF.Mult(syndrome[1], m_sigma[1]));//sigma3=D3+S1*sigma2

			m_sigma[3] = m_GF.Div(m_Det[3], m_Det[2]);//sigma4=Det5/Det4

			xnum = 0;
			for (t = 1; t < m_GF.m_num_element; ++t) {
				y = m_GF.Add(t, m_sigma[0]);
				y = m_GF.Add(m_GF.Mult(t, y), m_sigma[1]);
				y = m_GF.Add(m_GF.Mult(t, y), m_sigma[2]);
				y = m_GF.Add(m_GF.Mult(t, y), m_sigma[3]);
				if (y == 0) {
					logx[xnum] = m_GF.Log[t];
					if (logx[xnum] >= m_codelen)
						isSuc = false;
					++xnum;
				}
			}
			if (xnum < 4)
				isSuc = false;
			if (isSuc)
				for (t = 0; t < xnum; ++t) {
					err[logx[t]] = 1;
				}

			return isSuc;
		}
	}
	case 3: {
		if (m_Det[1] && m_Det[2]) {
			m_sigma[0] = syndrome[1];//sigma1=S1

			m_sigma[1] = m_GF.Mult(m_GF.Pow(syndrome[1], 2), syndrome[3]);//sigma2=(S1^2*S3
			m_sigma[1] = m_GF.Add(m_sigma[1], syndrome[5]);//+S5)
			m_sigma[1] = m_GF.Div(m_sigma[1], m_Det[1]);//*Det3^(-1)

			m_sigma[2] = m_GF.Div(m_Det[2], m_Det[1]);//sigma3=Det4/Det3

			xnum = 0;
			for (t = 1; t < m_GF.m_num_element; ++t) {
				y = m_GF.Add(t, m_sigma[0]);
				y = m_GF.Add(m_GF.Mult(t, y), m_sigma[1]);
				y = m_GF.Add(m_GF.Mult(t, y), m_sigma[2]);
				if (y == 0) {
					logx[xnum] = m_GF.Log[t];
					if (logx[xnum] >= m_codelen)
						isSuc = false;
					++xnum;
				}
			}
			if (xnum < 3)
				isSuc = false;
			if (isSuc)
				for (t = 0; t < xnum; ++t) {
					err[logx[t]] = 1;
				}

			return isSuc;
		}
	}
	case 2: {
		if (m_Det[0] && m_Det[1]) {
			m_sigma[0] = syndrome[1];//sigma1=S1

			m_sigma[1] = m_GF.Div(m_Det[1], m_Det[0]);//sigma2=Det3/Det2

			xnum = 0;
			for (t = 1; t < m_GF.m_num_element; ++t) {
				y = m_GF.Add(t, m_sigma[0]);
				y = m_GF.Add(m_GF.Mult(t, y), m_sigma[1]);
				if (y == 0) {
					logx[xnum] = m_GF.Log[t];
					if (logx[xnum] >= m_codelen)
						isSuc = false;
					++xnum;
				}
			}
			if (xnum < 2)
				isSuc = false;
			if (isSuc)
				for (t = 0; t < xnum; ++t) {
					err[logx[t]] = 1;
				}

			return isSuc;
		}
	}
	case 1: {
		if (m_Det[0]) {//fomula from Moon's book
			logx[0] = m_GF.Log[syndrome[1]];
			if (logx[0] >= m_codelen)
				isSuc = false;
			err[logx[0]] = 1;
			return isSuc;

		}
	}
	default:
		break;
	}
	return false;
}
/////////////////////////////////////////////////
void CBCHCodec::calGenerator(int codelen, int root0, int dist, int* &generator, int &codechk, int eBCH_opt)
{
	int *Zn = new int[codelen];
	for (int i = 0; i < codelen; i++)
		Zn[i] = i;
	for (int i = root0; i < root0 + dist - 1; i++) {	//Find all roots, containing conjugate roots; otherwise return -1.
		if (Zn[i % codelen] != -1) {
			Zn[i % codelen] = -1;
			int j = 2 * i;//conjugate of i
			while ((j - i) % codelen != 0) {
				Zn[j % codelen] = -1;
				j *= 2;
			}
		}
	}
	codechk = 0;
	for (int i = 0; i < codelen; i++) {			
		if (Zn[i] == -1) {
			codechk++;
		}
	}

	if (eBCH_opt == 1)
	{
		generator = new int[codechk + 2];
		generator[codechk + 1] = 0;
	}
	else
	{
		generator = new int[codechk + 1];		
	}
	
	generator[0] = 1;
	for (int i = 1; i <= codechk; i++)
		generator[i] = 0;

	for (int i = 0; i < codelen; i++) {		//Expand (x-a^1)(x-a^2)(x-a^3)...
		if (Zn[i] == -1) {
			for (int j = codechk; j > 0; j--)
				generator[j] = m_GF.Add(generator[j - 1], m_GF.Mult(m_GF.Exp[i], generator[j]));
			generator[0] = m_GF.Mult(generator[0], m_GF.Exp[i]);
		}
	}
	delete[] Zn;
	if (eBCH_opt == 1)
	{
		int* temp_generator = new int[codechk + 2];
		temp_generator[0] = 0;
		for (int i = 0; i < codechk + 1; i++)
		{
			temp_generator[i+1] = generator[i];
		}
		for (int i = 0; i < codechk + 2; i++)
		{
			generator[i] ^= temp_generator[i];
		}
		codechk += 1;
		delete[] temp_generator;
	}
}

